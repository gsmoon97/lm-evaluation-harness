"""
Usage:
   python parse_results_wsd.py --path <path_to_jsonl_file>
"""
import argparse
import json
import math
import os
import random
import warnings


random.seed(42) # fix the seed for reproducibility

def find_answer_idx(responses):
    candidates = []
    max_val = -1
    for idx, r in enumerate(responses):
        val = math.exp(r[0])
        if val == max_val:
            candidates.append((idx,r[1]))
        elif val > max_val:
            max_val = val
            candidates = [(idx,r[1])]
    
    # check if True value exists in 'responses' object (i.e., if any of the multiple-choice options would be generated by greedy sampling from the LM)
    if any([r[1] for r in responses]):
        # check if the multiple-choice option with the True value is included in 'candidates' (i.e., if the multiple-choice option that would be generated by greedy sampling from the LM does not have the highest logit)
        if not any([c[1] for c in candidates]):
            warnings.warn(f"Choice with the highest loglikelihood is not selected as the answer for this question: {responses}")
            # randomly select one multiple-choice option from all the multiple-choice options with the highest logits as the final answer
            answer_idx = random.choice([c[0] for c in candidates])
        else:
            # choose the multiple-choice option with True value as the answer (i.e., choose the multiple-choice option that would be generated by greedy sampling from the LM as the answer)
            for c in candidates:
                if c[1]:
                    answer_idx = c[0]
                    break
    else:
        # randomly select one multiple-choice option from all the multiple-choice options with the highest logits as the final answer
        answer_idx = random.choice([c[0] for c in candidates])
        
    assert candidates != [], f"No answer is predicted for this question: {candidates}"
    return answer_idx

def main():
    jsonl_files = [name for name in os.listdir(args.path) if name.endswith('.jsonl')]
    assert len(jsonl_files) <= 1, f'Found more than one .jsonl file in {args.path}!'
    with open(os.path.join(args.path, jsonl_files[0]), "r") as f:
        data = json.load(f)
    
    with open("/home/moongs/workspace/lm-evaluation-harness/data/ALL.json", "r") as f: #MCQ_NUM
        choices_data = json.load(f)
    
    id2choices = {}
    for d in choices_data:
        id2choices[d['id']] = list(d['key_dict'].values())

    id2answer_sense_key = {}
    
    for d in data:
        id = d['doc']['id']
        answer_idx = find_answer_idx(d['filtered_resps'])
        answer_sense_key = id2choices[id][answer_idx]
        id2answer_sense_key[id] = answer_sense_key
    lines = []
    for d in choices_data:
        id = d['id']
        answer_sense_key = id2answer_sense_key[id]
        lines.append(id + ' ' + answer_sense_key + '\n')
    lines[-1].strip('\n')
    with open(os.path.join(args.path, "ALL.txt"), "w") as f:
        f.writelines(lines)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--path", type=str, required=True)
    parser.add_argument("--model_size", type=str, default="13b")
    args = parser.parse_args()
    main()
